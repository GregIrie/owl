import ast
import threading
import traceback
from typing import Any, Dict
from .errors import OrchestratorError
from .logging import OrchestratorLogger

SAFE_BUILTINS = {
    'abs': abs,
    'min': min,
    'max': max,
    'sum': sum,
    'range': range,
    'len': len,
    'print': print,
}

class CodeExecutionError(OrchestratorError):
    pass

class Interpreter:
    '''
    Executes Python code generated by an LLM in a sandboxed environment.
    '''
    def __init__(self, timeout: float = 5.0):
        self.timeout = timeout
        self.logger = OrchestratorLogger.get_logger()

    def parse(self, code: str) -> ast.AST:
        self.logger.debug(f'Parsing code: {code}')
        try:
            tree = ast.parse(code, mode='exec')
        except SyntaxError as exc:
            self.logger.error(f'Syntax error: {exc}')
            raise CodeExecutionError(f'SyntaxError: {exc}')
        self._sanitize(tree)
        return tree

    def _sanitize(self, node: ast.AST) -> None:
        for child in ast.walk(node):
            if isinstance(child, (ast.Import, ast.ImportFrom)):
                raise CodeExecutionError('Module import is prohibited in executed code.')
            if isinstance(child, ast.Call) and isinstance(child.func, ast.Name) and child.func.id in ('open', 'exec', 'eval', '__import__'):
                raise CodeExecutionError(f'Use of prohibited function {child.func.id}.')

    def execute(self, code: str, inputs: Dict[str, Any] = None) -> Dict[str, Any]:
        self.logger.debug(f'Executing code with inputs: {inputs}')
        inputs = inputs or {}
        tree = self.parse(code)

        exec_globals: Dict[str, Any] = {'__builtins__': SAFE_BUILTINS}
        exec_locals: Dict[str, Any] = {}
        exec_locals.update(inputs)

        def _target():
            try:
                compiled = compile(tree, filename='<interpreter>', mode='exec')
                exec(compiled, exec_globals, exec_locals)
            except Exception:
                exec_locals['_interpreter_error'] = traceback.format_exc()

        thread = threading.Thread(target=_target)
        thread.daemon = True
        thread.start()
        thread.join(self.timeout)
        if thread.is_alive():
            self.logger.error('Code execution timeout')
            raise CodeExecutionError(f'Code execution exceeded timeout of {self.timeout}s.')
        if '_interpreter_error' in exec_locals:
            error = exec_locals.pop('_interpreter_error')
            self.logger.error(f'Code execution error: {error}')
            raise CodeExecutionError(f'Error during code execution:\n{error}')

        self.logger.debug(f'Code executed successfully, locals: {exec_locals}')
        return exec_locals
